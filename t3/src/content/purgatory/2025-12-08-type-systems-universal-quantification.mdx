---
title: "Type Systems #9: Universal Quantification"
description: ""
pubDate: "December 8 2025"
---

import Question from "../../components/Question.astro";
import SeriesNav from "../../components/SeriesNav.astro";

<SeriesNav
  seriesName="type systems"
  currentPart="9"
  prevPart="8"
  nextPart="10"
/>

With generic functions under our belt, we can type many function that you 
encounter in day-to-day programming. Like those!

```typescript
toString :: ∀A. A -> String
ifThenElse :: ∀A. Boolean -> A -> A -> A
equals :: ∀A. A -> A -> Boolean
```

But System F is actually a lot more powerful than that. In post #4 I claimed 
that System F generics shouldn't be a huge conceptual leap, but I lied :)

We will now be leaving the comfort zone of what we are used to in the day-to-day,
so we will now slow down the pace; for today I will just leave you with a little brain teaser.

We've seen plenty of functions now that are generic in their arguments,
and we can even define functions that are generic only in their return type, although
that's less common in practice.

```typescript
appplyTo42 :: ∀R. (Int -> R) -> R
appplyTo42 = ΛR. λf: (Int -> R). f 42
```

From just the type we can tell that `applyTo42` doesn't really care about what the function it recieves returns -- it'll just forward the return value anyway. What's important to `applyTo42` is only that the function takes an `Int`, so that it can
shove `42` into it.

In particular, by making the return type generic, we can ensure *at the type level*
that `applyTo42` doesn't do anything to the return value of `f` -- all it can do is
return it.

Well. Nothing in System F prevents us from putting `∀` basically anywhere in
a type definition. What all our previous examples have in common is that we 
always put the `∀` quantifier at the leftmost postition in the type.

Let's do a small but interesting change, by moving the `∀` quantifier into the 
the first pair of parentheses.

```typescript
weird :: (∀R. Int -> R) -> Bool
```

Since the `R` in `∀R` cannot be referenced outside where it is defined, I had to fix the
return type to `Bool` here.

What does this type even represent? Can you come up with an implementation of `weird`?



<SeriesNav
  seriesName="type systems"
  currentPart="9"
  prevPart="8"
  nextPart="10"
  position="footer"
/>
