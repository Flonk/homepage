---
title: "Type Systems #15: A Church Encoding of Lists"
description: ""
pubDate: "December 14 2025"
---

import Question from "../../components/Question.astro";
import SeriesNav from "../../components/SeriesNav.astro";

<SeriesNav
  seriesName="type systems"
  currentPart="15"
  prevPart="14"
  nextPart="16"
/>

We've seen a lot of lambda calucli so far, haven't we! Each one builds upon the 
last, adding new features and new concepts. We saw...
- The untyped lambda calculus, which has no types at all.
- The simply typed lambda calculus, which adds simple types like `Bool` and `Int`,
and function types like `Int → Int`.
- System F, which adds generic functions, like `toString :: ∀A. A → String`.
- System F\<:, which adds subtyping.

Quite an impressive repertoire -- we've built that up from nothing, and you know
all the nitty-gritty details now!

But believe me when I say that we are far from done. To get to more of the
juicy bits however, we will need a more complicated data structure we can use
for examples.

All the way back in post #1 we saw how we can encode booleans in the
untyped lambda calculus using so-called Church encodings...  and while it's a 
fun party trick, and Church encodings are very prevalent in every post or paper
about type theory, I purposefully avoided giving them too much attention, because
in regular programming languages you never use them. Like yes you can encode
`true` as `λt. λf. t` -- but in the real world we just use a single bit
instead.

Anyhow, it turns out that the type of a church-encoded list of integers is
`IntList = ∀R. R → (Int → R → R) → R`, which looks scary at first, but it'll 
turn out that you knew it all along.


## Church Encoding of Lists

As programmers, we sometimes get to ask questions like, "what even *is* an 
AbstractDtoFactory? What is it's essence?", and then spend hours on delineating
what does and what doesn't constitute the essence of an AbstractDtoFactory. It
makes me feel like a philosopher at times.

So... yeah, what is the essence of a list? Can we single out a single core 
property that all lists have? Like a single thing you can *do* with a list, that
you cannot do to non-lists?

We could argue that lists are mappable, and that `map` is the essence of lists.
Or perhaps `filter` is more fundamental? Are lists collections you can filter?
Maybe what defines lists is that you can `concatenate` two of them to make a larger
one.

Well, these are all good candidates, but there is one that is more fundamental
than all of them: A **fold**, or what we could call `reduce` in typescript.
Folds allow you to merge a list into a single value, for example to sum a list
of integers. The "single value" you are returning can be of any type though, 
and that includes lists themselves, which makes folds powerful enough to express `map`,
and `filter`, and `concatenate` as well.

It's a fun exercise so give it a try! Implement the other three functions
in terms of just `list.reduce(fn, initialValue)`!


<Question
  n={1}
  question={`Implement const map = <A, B>(list: A[], fn: (a: A) => B): B[]`}
>
```typescript
const map = <A, B>(list: A[], fn: (a: A) => B): B[] => {
  return list.reduce((acc, a) => {
    acc.push(fn(a));
    return acc;
  }, [] as B[]);
};
```
</Question>

<Question
  n={2}
  question={`Implement const filter = <A>(list: A[], predicate: (a: A) => boolean): A[]`}
>
```typescript
const filter = <A>(list: A[], predicate: (a: A) => boolean): A[] => {
  return list.reduce((acc, a) => {
    if (predicate(a)) { 
      acc.push(a);
    }
    return acc;
  }, [] as A[]);
};
```
</Question>

<Question
  n={3}
  question={`Implement const concatenate = <A>(list1: A[], list2: A[]): A[]`}
>
```typescript
const concatenate = <A>(list1: A[], list2: A[]): A[] => {
  return list1.reduce((acc, a) => {
    acc.push(a);
    return acc;
  }, list2.slice());
};
```
</Question>



Yeah.. folds are powerful. What would the type of a fold be though? It takes
an initial value, and a function that merges an element of the list and the
accumulated value, and then we return the next accumulator. If the list contains
`Int`s, and the accumulator is of type `R`, then the type of `fold` would be:

```typescript
fold :: ∀R. R → (Int → R → R) → R
```

Wait. What was the type of our church encoded list again?

```typescript
IntList = ∀R. R → (Int → R → R) → R
```

Oh yeah. It's the same.


## For completeness

Let's write out the full church encoding of lists of integers for completeness.
We use a linked-list kind of structure here, where `nil` is the empty list, and
`cons head tail` constructs a new list with `head` as the first element, and
`tail` as the rest of the list.

When we define `nil` and `cons` constructors that return `IntLists` (that have
the same type as a fold), we are essentially defining how a fold should behave
for those two cases. Folding a `nil` returns the `nilCase` or `initialValue`,
and folding a `const head tail` recursively applies a 2-parameter function to `head`,
and the result of folding the `tail`.


```typescript
nil : IntList
nil = ΛR.
  λnilCase: R.
  λconsCase: Int → R → R.
    nilCase

cons : Int → IntList → IntList
cons = λhead: Int. λtail: IntList.
    ΛR.
      λnilCase: R.
      λconsCase: Int → R → R.
        consCase head (tail [R] nilCase consCase)
```

With these helper functions we can now easily construct a list like so:

```typescript
myList : IntList
myList = cons 1 (cons 2 (cons 3 nil))
```

This is the list containing the integers 1, 2, and 3. And, well, folding
a list is pretty easy, since a list is literally just it's own fold function:

```typescript
fold = λlist. list
sum = fold [Int] myList 0 (λx. λacc. add x acc) // sum == 6
```

And once we have folds, we can do any other list operation, meaning we have successfully
defined lists in terms of just pure lambda calculus! It's functions all the way down.

---

I'm aware that I have rushed through this a bit, but this definition of lists
is merely a vessel to demonstrate more advanced type system features in the
coming posts. Feel free to implement this church-encoding of lists in typescript
to get a better feel, it really is a fun exercise, and you'll get to really 
learn functional programming concepts doing it!

<SeriesNav
  seriesName="type systems"
  currentPart="15"
  prevPart="14"
  nextPart="16"
  position="footer"
/>
