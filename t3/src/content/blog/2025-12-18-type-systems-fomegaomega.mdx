---
title: "Type Systems #19: System FÏ‰Ï‰..? A Recap of Type Systems"
description: ""
pubDate: "December 18 2025"
---

import Question from "../../components/Question.astro";
import SeriesNav from "../../components/SeriesNav.astro";

<SeriesNav
  seriesName="type systems"
  currentPart="19"
  prevPart="18"
  nextPart="20"
/>

Phew. That was a lot of material in the last few posts, wasn't it?
Are.. are any of you even still here? Did anyone make it this far?

If you did, congratulations! This stuff is not easy and very niche,
and I'm proud of you.

Last post we looked at Higher-Kinded Types which is a huge step up
in abstraction, so let's take a breather today and look at how far
we've come.

## Untyped Lambda Calculus

The very beginning of this series! Do you still remember when we
wrote our first lambdas ðŸ¥²

```typescript
id = Î»x. x
fiveTimes = Î»f. Î»x. f (f (f (f (f x))))
```

Functions and function application, that's all you need to compute
anything! You can even model Lists or Numbers or the 2020 Ford Mustang
Mach-E with Church encodings.

But oh no, there are no types!

## Simply Typed Lambda Calculus

We chucked a couple of base types in there and made our lambdas
typesafe ðŸ˜Œ

```typescript
add :: Int â†’ Int â†’ Int

addTwice :: Int â†’ Int â†’ Int
addTwice = Î»x: Int. Î»y: Int. add (add x y) y
```

Having types is just so nice man. It prevents all the bugs.

## System F

Generic functions are lowkey fire ðŸ”¥

```typescript
toString :: âˆ€A. A â†’ String
```

Imagine having to spell out literally infinite variants of the
`toString` function for every type in your program. No thanks.

Generic functions can even be rank-n like `(âˆ€A. A â†’ A) â†’ Int`,
and we can implement type hiding via existential types, like
`âˆƒA. (A, A â†’ Int, A â†’ String)`. Juicy! ðŸ§ƒ

## System F\<:

We can define functions that work on a whole bunch of types,
but not necessarily all of them. ðŸŒ™

```typescript
toString :: âˆ€A <: Stringifiable. A â†’ String
toString = Î›A <: Stringifiable. Î»x: A. magic
```

Without subtyping, TypeScript would be ultra useless!

## System FÏ‰

Generic types are nice for like containers and stuff ðŸ§º But we
need kinds to distinguish types from generics.

```typescript
List :: Type â†’ Type
List = Î»A: Type. âˆ€R: Type. R â†’ (A â†’ R â†’ R) â†’ R

Natural :: (Type â†’ Type) â†’ (Type â†’ Type) â†’ Type
Natural = Î»F. Î»G. âˆ€A. F A â†’ G A
```

It's literally a lambda calculus on top of a lambda calculus! ðŸ˜µ

## System FÏ‰\<:

Okay we didn't actually look at this one but you literally just
take System F and tack on the subtyping part and the generics as well.
I think it goes by many names but "FÏ‰ with subtyping" is
probably the most accurate. So there you go, you know that one as well ðŸ‘

---

That's pretty good hey! So many type systems, all building on each other.
It's a beautiful thing. And we've learned them all, from the ground up!

## What's next? System FÏ‰Ï‰?

Err so the jump from STLC to System F introduced quantification over
types right, like `âˆ€A. A â†’ A`. And then System FÏ‰ introduced
kinds.

BUT LIKE WHAT IF.

HEAR ME OUT.

Let's add quantification over kinds? Like, just one more layer of
abstraction bro. Please bro. One more quantifier makes us so expressive
bro.

???

```typescript
PolyKinded :: âˆ€K1: Kind. âˆ€K2: Kind. (K1 â†’ K2) â†’ Type
```

What would that do?

No I mean, just no, stop. Today was supposed to be a breather. [Read
through this](https://ghc.gitlab.haskell.org/ghc/doc/users_guide/exts/poly_kinds.html)
if kind polymorphism sounds interesting to you, Haskell internals
have a usecase for it. But I'm not gonna touch that with a ten foot
pole today.

<SeriesNav
  seriesName="type systems"
  currentPart="19"
  prevPart="18"
  nextPart="20"
  position="footer"
/>
