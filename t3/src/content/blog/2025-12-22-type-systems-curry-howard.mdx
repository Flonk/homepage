---
title: "Type Systems #23: The Curry-Howard Isomorphism"
description: ""
pubDate: "December 22 2025"
---

import Question from "../../components/Question.astro";
import SeriesNav from "../../components/SeriesNav.astro";

<SeriesNav
  seriesName="type systems"
  currentPart="23"
  prevPart="22"
  nextPart="24"
/>

Shoutout to my man Haskell Curry for being so instrumental for computer science
that he gets not one but three programming languages named after him
(Haskell being the most famous), as well as a functional programming concept
(currying)! His most famous contribution to computer science is probably the
**Curry-Howard isomorphism**, which connects mathematical logic with types
and computer programs. Really unexpected stuff.

## Propositions as Types

The Curry-Howard isomorphism states that we can take any proposition in logic,
like "If it rains, the ground gets wet", and interpret it as a type in a programming
language. Now "If it rains, the ground gets wet" is not such a good example,
because (cue Carl Sagan voice) to model rain, one must first invent the
universe; so let's pick a very simple logical proposition instead:

$$
A \land B → A
$$

The `^` symbol in logic means "and", and the arrow is implication,
so this proposition states that if both `A` and `B` are true,
then `A` is true, given any `A` and `B`. This is of course ultra trivial.

Curry-Howard says we can map this proposition to a distinct type:

```typescript
proposition :: A * B → A
```

That is, the "and" operator `^` in logic corresponds to the product type `*`
(as discussed last post; it's the tuple type), and the implication `→` in logic
corresponds to the function type `→` in programming languages.

"Proving" that this proposition is true is as easy (or hard) as finding a value,
any value, of this type. For our example this should be pretty easy right --
the type signature looks like the `first` function that gives you the first
element of a tuple.

```typescript
type Pair<A, B> = { fst: A; snd: B };
const proof = <A, B>({ fst }: Pair<A, B>): A => fst;
```

That code typechecks, so the proposition is true!

---

The other common logical operators map similarly:

| Logic             | Programming Type   |
| ----------------- | ------------------ |
| `A ∧ B` (and)     | `A * B` (product)  |
| `A ∨ B` (or)      | `A + B` (sum)      |
| `A → B` (implies) | `A → B` (function) |
| `⊤` (true)        | `1` (top type)     |
| `⊥` (false)       | `0` (bottom type)  |

To prove a false proposition like `A → ⊥` (if `A` then false),
we would need to find a value of type

```typescript
const falseProof = <A>(a: A): never => ...
```

But there is no way to implement this function, because you can
never produce a value of type `never`. Checkmate, proposition is false! <sup>[1](#footnote1)</sup>

---

The Curry-Howard isomorphism is really cool and to me anyway came
completely out of the blue when I first heard of it, like it's two
separate areas that I didn't expect to be connected, coming from a
typescript background.

It's also a really nice trick for
toddlers like me who know programming but not logic. Whenever I
come across a logical proposition in the wild, I usually map it to types
and then I'm like "aah, I understand what this is saying now" :D

Of course, then there are the grown-ups who know both maths _and_
programming, and they are interested in Curry-Howard for a totally different
reason: All mathematical proof-finding is just an application of logic at
the end of the day, so a type checker for any sufficiently expressive type
system is _also_ something that can prove (or verify) mathematical theorems
for you!

Proof assistants like Coq or Agda use this fact to help mathematicians
formalize and check their proofs by letting them write proofs as programs
in a particularly strong variant of the lambda calculus -- the Calculus
of Constructions.

<SeriesNav
  seriesName="type systems"
  currentPart="23"
  prevPart="22"
  nextPart="24"
  position="footer"
/>

---

<a name="footnote1" class="footnote">
  <sup>
    [1] There is a one concrete type `A` for which you could implement this
    function, namely when `A` is itself `never`. That maps to the proposition `⊥
    → ⊥`, which is true. But the original proposition as stated is not true, as
    `A` is generic.{" "}
  </sup>
</a>
