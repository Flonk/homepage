---
title: "Type Systems #4: STLC is not enough!"
description: ""
pubDate: "December 3 2025"
---

import Question from "../../components/Question.astro";
import SeriesNav from "../../components/SeriesNav.astro";

<SeriesNav
  seriesName="type systems"
  currentPart="4"
  prevPart="3"
  nextPart="5"
/>

I have brought a fresh lambda term for you, but I forgot to type it! What do you
think its type should be?

<Question n={1} question="apply = Î»f. (Î»x. f x)">
  ðŸ¤”
</Question>

Not so easy, is it. It feels like `apply`s type should depend on whatever function
you pass in.. if you pass in `plusOne`, then `apply plusOne` should be a function
`Int â†’ Int`. But if you pass in `not`, then `apply not` should be a function
`Boolean â†’ Boolean`.

Or in other words, we would really like `apply` to be generic.

But if we recall the rules of simply typed lambda calculus, then we see that
we have no way to express this genericity. Function parameters
in STLC must be of a type that's allowed by the language, and that's either
a base type (we chose `Int`, `Boolean`, `String` previously), or a function type like
`Int â†’ Int`.

That is to say, STLC will allow us to define concrete instances of `apply`, like
these:

```typescript
applyInt = Î»f: (Int â†’ Int). Î»x: Int. f x
applyBool = Î»f: (Boolean â†’ Boolean). Î»x: Boolean. f x
```

But we can't define a generic `apply` that works for all types. This is the 
hard limit of STLC, and we will need to move to a more powerful type system
to express these kinds of functions.

<SeriesNav
  seriesName="type systems"
  currentPart="4"
  prevPart="3"
  nextPart="5"
  position="footer"
/>
